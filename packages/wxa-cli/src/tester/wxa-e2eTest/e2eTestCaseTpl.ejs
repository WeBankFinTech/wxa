/* eslint-disable no-console */
/* eslint-disable no-undef */
import automator from 'miniprogram-automator';
import path from 'path';
import fs, { chmod } from 'fs';
import looksSame from 'looks-same';

let miniProgram;
let page;
let testCaseNameArr = JSON.parse('<%- testCaseNameArr %>')
let testDir = '<%= testDir %>';
let screenshotDirname = '<%- screenshotPath %>'
let screenshotDiff = <%- screenshotDiff %>;
let mockApi = <%- mockApi %>;
let base = <%- base %>;
let customExpect = <%- customExpect%>
const sleep = t => new Promise(resolve => setTimeout(resolve, t));


expect.extend({
    toBeEmpty(diffDir, testName) {
        let files = fs.readdirSync(diffDir);
        let relativePath = path.relative(process.cwd(), diffDir);
        if (files.length === 0) {
            return {
                message: () => `<${testName}>截图比对通过`,
                pass: true
            };
        }
        return {
            message: () => `<${testName}>截图比对失败,${relativePath}`,
            pass: false
        };
    }
});

beforeAll(async () => {
    jest.setTimeout(300000);
    miniProgram = await automator.launch({
        cliPath: '<%= cliPath %>',
        projectPath: path.resolve(process.cwd(), './dist/')
    });

    page = await miniProgram.currentPage();
}, 300000);

afterAll(async () => {
    if (miniProgram) await miniProgram.close();
});

for (let j = 0; j < testCaseNameArr.length; j++) {
    let testName = testCaseNameArr[j];
    test(testName, async () => {
        let screenshotDir = path.join(testDir, '.replay_result', screenshotDirname, testName, 'screenshot');
        let baseScreenshot = path.join(testDir, testName, 'base_screenshot');
        if (base) {
            screenshotDir = baseScreenshot;
        }
        let diffDir = path.join(screenshotDir, 'diff');
        if (base) {
            try {
                fs.rmdirSync(screenshotDir);
            } catch (err) {
            }
        }
        try {
            mkdirsSync(screenshotDir)
            if (!base) {
                mkdirsSync(diffDir);
            }
        } catch(err) {
        }

        let record = require(path.join(testDir, testName, `./record.js`));
        let screenCount = 0;
        // mock接口
        let apiMockMap = require(path.join(testDir, testName, `./api.json`));
        // for (let i = 0; i < mockWxMethodConfig.length; i++) {
        <% mockWxMethodConfig.forEach(function(mockItem){ %>
            <% if(mockItem.name !== 'request' || mockApi) {%>
        await miniProgram.mockWxMethod(
            '<%- mockItem.name %>',
            function(config, apiMockMap) {
                let mapKey = `<%- mockItem.tpl %>`
                if (apiMockMap[mapKey] && apiMockMap[mapKey].length > 0) {
                    console.log(mapKey, 'mock success')
                    <% if(mockItem.name === 'request') {%>
                    return apiMockMap[mapKey].shift();
                    <% } else {%>
                        return apiMockMap[mapKey][0];
                    <% }%>
                }
                return new Promise(resolve => {
                    config.success = res => resolve(res)
                    config.fail = res => resolve(res)
                    // origin 指向原始方法
                    console.log(mapKey, 'no mock')
                    this.origin(config)
                })
            },
             apiMockMap
        )
        <% }}); %>

        // 开始回放+截屏
        let startPage = record[0].action.page || record[0].action.appStartPage;
        page = await miniProgram.reLaunch(`/${startPage}`);
        let element;
        await page.waitFor(3000);
        for (let i = 0; i < record.length; i++) {
            let recordItem = record[i];
            let recordAction = recordItem.action;
            let lastRecordAction = record[i - 1]?.action;
            while (true) {
                page = await miniProgram.currentPage()
                if (recordAction.event === 'switchTab') {
                    await sleep(4000);
                    break;
                } else if (page.path === (recordAction.page || recordAction.appStartPage).split('?')[0]) {
                    if (!lastRecordAction) break;
                    let lastPagePath = (lastRecordAction.page || lastRecordAction.appStartPage).split('?')[0]
                    if (page.path !== lastPagePath) {
                        // 和上一步的页面path不一致，说明页面切换了，需要等久一点让页面ready
                        await sleep(3000);
                    }
                    break;
                }
                await sleep(1000);
            }
            // 这里要区分下，如果是switchtab跳转页面，是没有elementid的
            if (recordAction.id) {
                let idPath = recordAction.id.split('-');
                await page.waitFor(`.${idPath[0]}`);
                element = await page.$(`.${idPath[0]}`)
                for (let j = 1; j < idPath.length; j++) {
                    element = await element.$(`.${idPath[j]}`)
                }
            } else {
                element = null;
                await sleep(3000)
            }

            let diff = screenshotDiff;
            if (record[i-1] && typeof record[i-1].screenshotDiff !== 'undefined') {
                diff = screenshotDiff;
            }
            let same = await screenShot({
                screenshotDir,
                screenCount: screenCount++,
                diff,
                baseScreenshot
            })
            if (customExpect && i !== 0 && record[i - 1].customExpect && typeof record[i - 1].customExpect === 'function') {
                record[i - 1].customExpect();
            }

            if (!!~['tap', 'longpress'].indexOf(recordAction.event)) {
                await element[recordAction.event]();
            } else if (!!~['input'].indexOf(recordAction.event)) {
                await element[recordAction.event](recordAction.detail.value);
            } else if (!!~['switchTab'].indexOf(recordAction.event)) {
                await miniProgram.switchTab(path.resolve('/', recordAction.path))
            } else if (!!~['touchstart', 'touchmove', 'touchend'].indexOf(recordAction.event)) {
                await element[recordAction.event]({
                    touches: recordAction.touches,
                    changedTouches: recordAction.changedTouches
                });
            } else {
                await element.trigger(recordAction.event, recordAction.detail);
            }
            await page.waitFor(300)
        }
        // await miniprogram.restoreWxMethod('request');
        await sleep(5000)
        let same = await screenShot({
            screenshotDir,
            screenCount: screenCount,
            diff: screenshotDiff || record[record.length - 1].sceeenshotDiff,
            baseScreenshot
        })
        // 无diff图片，则比对通过
        if (!base) {
            expect(diffDir).toBeEmpty(testName);
        }
    })
}

async function screenShot({screenshotDir, screenCount, diff, baseScreenshot}) {
    let actualImagePath = path.join(screenshotDir, `${screenCount}.png`);
    let expectPath = baseScreenshot;
    await miniProgram.screenshot({path: actualImagePath});
    if (diff) {
        let same = await imageDiff(actualImagePath, expectPath, path.join(screenshotDir, `diff/${screenCount}.png`));
        return same;
    }
    return true;
}

function imageDiff(actualImage, expectImage, diffPath) {
    return new Promise((resolve, reject) => {
        looksSame(actualImage, expectImage, function(err, res) {
            if(err) {
                return resolve(err);
            }
            if (res.equal) {
                return resolve(res);
            }
            let relativePath = path.relative(process.cwd(), actualImage);
            if (!diffPath) {
                return resolve({errMsg: `截图比对不通过：${relativePath}`});
            }
            looksSame.createDiff({
                reference: expectImage,
                current: actualImage,
                diff: diffPath,
                highlightColor: '#ff00ff', // color to highlight the differences
                strict: false, // strict comparsion
                tolerance: 5,
                antialiasingTolerance: 3,
                ignoreAntialiasing: true, // ignore antialising by default
                ignoreCaret: true // ignore caret by default
            }, function(error, res) {
                if (error) {
                    return resolve(error);
                }
                return resolve({errMsg : `截图比对不通过：${relativePath}，请查看${diffPath}`});
            });
        })
    })
}
// 递归创建目录 同步方法
function mkdirsSync(dirname) {
    if (fs.existsSync(dirname)) {
      return true;
    } else {
      if (mkdirsSync(path.dirname(dirname))) {
        fs.mkdirSync(dirname);
        return true;
      }
    }
}
